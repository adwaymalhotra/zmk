// Layer
#define GR   0
#define GAME 1
#define NAV  2
#define SYM  3
#define FN   4
#define SYS  5

/* ZMK Headers */
#include <behaviors.dtsi>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/outputs.h>
/* urob's helper (must be after including behaviors.dtsi) */
#include <zmk-helpers/helper.h>
/* my definitions */
#include "extra_keys.h"
#include "keys_en_gb_extended.h"

#define ALT LALT
#define MET LGUI
#define SFT LSHFT
#define CTL LCTL
#define _____ &none

#define PRIOR_IDLE_MS 160
#define QUICK_TAP_MS 175
#define TAPPING_TERM 200

/* Homerow Mods */
#define MAKE_HT(NAME, MODE, HOLD, TAP, TRIGGER_POS) \
    ZMK_BEHAVIOR(NAME, hold_tap, \
        flavor = MODE; \
        tapping-term-ms = <TAPPING_TERM>; \
        quick-tap-ms = <QUICK_TAP_MS>; \
        bindings = <HOLD>, <TAP>; \
        require-prior-idle-ms = <PRIOR_IDLE_MS>; \
        hold-trigger-key-positions = <TRIGGER_POS>; \
    )

#define MAKE_HRM(NAME, HOLD, TAP, TRIGGER_POS) \
    MAKE_HT(NAME, "tap-preferred", HOLD, TAP, TRIGGER_POS)

MAKE_HRM(hrm_left, &kp, &kp, KEYS_R THUMBS)
MAKE_HRM(hrm_right, &kp, &kp, KEYS_L THUMBS)
MAKE_HRM(hrl_left, &mo, &kp, KEYS_R THUMBS)
MAKE_HRM(hrl_right, &mo, &kp, KEYS_L THUMBS)

#define SL(KEY) &hrm_left SFT KEY
#define CL(KEY) &hrm_left CTL KEY
#define AL(KEY) &hrm_left ALT KEY
#define ML(KEY) &hrm_left MET KEY

#define SR(KEY) &hrm_right SFT KEY
#define CR(KEY) &hrm_right CTL KEY
#define AR(KEY) &hrm_right ALT KEY
#define MR(KEY) &hrm_right MET KEY

#define SYL(KEY) &hrl_left SYS KEY
#define SYR(KEY) &hrl_right SYS KEY

MAKE_HRM(mts, &sk, &caps_word, KEYS_L KEYS_R)
MAKE_HRM(mtb, &sk, &bsdel, KEYS_L KEYS_R)
MAKE_HRM(lts, &mo, &caps_word, KEYS_L KEYS_R)

MAKE_HT(thl, "tap-preferred", &mo, &kp, KEYS_L KEYS_R THUMBS)
MAKE_HT(thm, "tap-preferred", &kp, &kp, KEYS_L KEYS_R THUMBS)

MAKE_HT(mt_bsdel, "hold-preferred", &kp, &bsdel, KEYS_L KEYS_R THUMBS)
MAKE_HT(lt_bsdel, "hold-preferred", &mo, &bsdel, KEYS_L KEYS_R THUMBS)

MAKE_HT(lt_comm, "tap-preferred", &mo, &com_sem, KEYS_R)

/* All Other Behaviors */
&sk {
    release-after-ms = <1000>;
    quick-release;
};

&lt {
  tapping-term-ms = <TAPPING_TERM>;
  quick-tap-ms = <QUICK_TAP_MS>;
  flavor = "hold-preferred";
};

&mt {
  tapping-term-ms = <TAPPING_TERM>;
  quick-tap-ms = <QUICK_TAP_MS>;
  flavor = "hold-preferred";
};

&caps_word {
  continue-list = <UNDERSCORE MINUS BACKSPACE DELETE>;
  /delete-property/ ignore-modifiers;
};

/* Tri State for Alt-Tab in a layer. */
ZMK_TRI_STATE(alt_tab, bindings = <&kt LALT>, <&kp TAB>, <&kt LALT>; ignored-key-positions = <LT3>;)
ZMK_TRI_STATE(met_tab, bindings = <&kt LGUI>, <&kp TAB>, <&kt LGUI>; ignored-key-positions = <LT3>;)

/* Morphs */
ZMK_MOD_MORPH(bsdel,    bindings = <&kp BACKSPACE>, <&kp DELETE>; mods = <(MOD_LALT|MOD_LGUI|MOD_LSFT)>;)
ZMK_MOD_MORPH(dlr_gbp,  bindings = <&kp DLLR>, <&uc_gbp>        ; mods = <(MOD_LSFT|MOD_RSFT)>;)
ZMK_MOD_MORPH(amps_eur, bindings = <&kp AMPS>, <&uc_eur>        ; mods = <(MOD_LSFT|MOD_RSFT)>;)
ZMK_MOD_MORPH(star_rup, bindings = <&kp STAR>, <&uc_rup>        ; mods = <(MOD_LSFT|MOD_RSFT)>;)
ZMK_MOD_MORPH(dot_col,  bindings = <&kp DOT>, <&kp COLON>       ; mods = <(MOD_LSFT)>;)
ZMK_MOD_MORPH(com_sem,  bindings = <&kp COMMA>, <&kp SEMICOLON> ; mods = <(MOD_LSFT)>;)
ZMK_MOD_MORPH(sqt_dqt,  bindings = <&kp SQT>, <&kp GB_DQT>      ; mods = <(MOD_LSFT)>;)
ZMK_MOD_MORPH(lpar_lt,  bindings = <&kp LPAR>, <&kp LT>         ; mods = <(MOD_LSFT)>;)
ZMK_MOD_MORPH(rpar_gt,  bindings = <&kp RPAR>, <&kp GT>         ; mods = <(MOD_LSFT)>;)

/* Macros */
ZMK_MACRO(uc_deg,  bindings = <&kp RALT>, <&kp O>,           <&kp O>  ;)
ZMK_MACRO(uc_gbp,  bindings = <&kp RALT>, <&kp LS(L)>,       <&kp EQL>;)
ZMK_MACRO(uc_eur,  bindings = <&kp RALT>, <&kp C>,           <&kp EQL>;)
ZMK_MACRO(uc_rup,  bindings = <&kp RALT>, <&kp R>,           <&kp EQL>;)
ZMK_MACRO(vi_sav,  bindings = <&kp ESC>,  <&kp COLON &kp W>, <&kp RET>; wait-ms =<20>;)
ZMK_MACRO(find,    bindings = <&kp LC(F)>;)
ZMK_MACRO(pre_wor, bindings = <&kp LC(LEFT)>;)
ZMK_MACRO(nex_wor, bindings = <&kp LC(RIGHT)>;)
ZMK_MACRO(pre_tab, bindings = <&kp LC(LS(TAB))>;)
ZMK_MACRO(nex_tab, bindings = <&kp LC(TAB)>;)
ZMK_MACRO(pre_dsk, bindings = <&kp LC(LG(LEFT))>;)
ZMK_MACRO(nex_dsk, bindings = <&kp LC(LG(RIGHT))>;)
ZMK_MACRO(cut,     bindings = <&kp LC(X)>;)
ZMK_MACRO(copy,    bindings = <&kp LC(C)>;)
ZMK_MACRO(paste,   bindings = <&kp LC(V)>;)
ZMK_MACRO(half_dn, bindings = <&kp LC(D)>;)
ZMK_MACRO(half_up, bindings = <&kp LC(U)>;)
ZMK_MACRO(del_wor, bindings = <&kp LC(BSPC)>;)

/* Keymap */
#define LEFT_THUMBS &thm MET TAB &kp SFT &lt NAV ESC
#define RIGHT_THUMBS &thl SYM SPC &mt_bsdel CTL 0 &thl FN RET
#define TRANS_THUMBS &trans &trans &trans
#define TRANS_5 &trans &trans &trans &trans &trans

#define _LAYER(NAME, LT, RT, LM, RM, LB, RB, LH, RH) \
  ZMK_LAYER(NAME, \
    X_LT LT RT X_RT \
    X_LM LM RM X_RM \
    X_LB LB RB X_RB \
    X_LH LH X_MH RH X_RH \
  )
#define LAYER(NAME, LT, RT, LM, RM, LB, RB) _LAYER(NAME, LT, RT, LM, RM, LB, RB, LEFT_THUMBS, RIGHT_THUMBS)
#define TLAYER(NAME, LT, RT, LM, RM, LB, RB) _LAYER(NAME, LT, RT, LM, RM, LB, RB, TRANS_THUMBS, TRANS_THUMBS)
#define TRANS_LAYER(NAME) LAYER(NAME, TRANS_5, TRANS_5, TRANS_5, TRANS_5, TRANS_5, TRANS_5)

// Base
LAYER(Graphite,
  &kp B &kp L &kp D &kp W &kp Z, &sqt_dqt &kp F &kp O    &kp U     &kp J,
  &kp N &kp R &kp T &kp S &kp G, &kp Y    &kp H &kp A    &kp E     &kp I,
  &kp Q &kp X &kp M &kp C &kp V, &kp K    &kp P &dot_col &kp MINUS &com_sem
)

#if defined GAME_LAYER_KEYS
  ZMK_LAYER(game, GAME_LAYER_KEYS)
#else
  TRANS_LAYER(game)
#endif

LAYER(Nav,
  &alt_tab &kp LS(TAB) &met_tab &kp PSCRN &none   , &kp HOME &kp PG_DN    &kp PG_UP    &kp END    &sk RALT,
  &sk SFT  &sk ALT     &sk MET  &sk CTL   &vi_sav , &kp LEFT &kp DOWN     &kp UP       &kp RIGHT  &kp RET,
  &kp TAB  &key_repeat &pre_tab &nex_tab  &del_wor, &kp CAPS &kp C_VOL_DN &kp C_VOL_UP &kp C_MUTE &kp INS
)

TLAYER(Sym,
  &kp EQUAL &kp LBRC &kp LBKT &lpar_lt &uc_gbp , &kp DOT  &kp N7 &kp N8 &kp N9 &kp PLUS ,
  &sk SFT   &sk ALT  &sk MET  &sk CTL  &kp PIPE, &kp FSLH &kp N4 &kp N5 &kp N6 &kp N0   ,
  &kp QMARK &kp RBRC &kp RBKT &rpar_gt &kp BSLH, &kp STAR &kp N1 &kp N2 &kp N3 &kp MINUS
)

TLAYER(Fn,
 &kp F1       &kp F2       &kp F3       &kp F4       &kp F5     , &kp F6      &kp F7       &kp F8       &kp F9       &kp F10,
 &sk SFT      &sk ALT      &sk MET      &sk CTL      &sys_reset , &sys_reset  &kp C_BRI_DN &kp C_BRI_UP &kp F12      &kp F11,
 &bt BT_SEL 0 &bt BT_SEL 1 &bt BT_SEL 2 &bt BT_SEL 3 &bootloader, &bootloader &bt BT_CLR   &out OUT_BLE &out OUT_USB &tog GAME
)

TLAYER(sys,
  &bt BT_SEL 0 &bt BT_SEL 1 &bt BT_SEL 2 &bt BT_SEL 3 &bt BT_CLR , &bt BT_CLR_ALL &none &none &none &tog GAME,
  &none        &none        &kp C_BRI_UP &kp C_BRI_DN &sys_reset , &sys_reset     &none &none &none &none,
  &out OUT_BLE &out OUT_USB &none        &none        &bootloader, &bootloader    &none &none &none &none
)

ZMK_CONDITIONAL_LAYER(function_condition, NAV SYM, FN)

/* Combos */
#undef COMBO_TERM
#define COMBO_TERM 50
#define COMBO_LAYERS GR NAV SYM 

#define SIMPLE_COMBO(NAME, KEY, COMBO_KEYS) \
ZMK_COMBO(NAME, KEY, COMBO_KEYS, COMBO_LAYERS, COMBO_TERM, COMBO_TERM)

/* right side combos */
SIMPLE_COMBO(tilde, &kp LS(GB_HASH), RM0 RT0)
SIMPLE_COMBO(pipe,  &kp GB_BSLH,     RM0 RB0)

SIMPLE_COMBO(slash, &kp FSLH, RT1 RM1)
SIMPLE_COMBO(rpar,  &rpar_gt, RM1 RB1)

SIMPLE_COMBO(ques, &kp QUESTION, RT2 RM2)
SIMPLE_COMBO(rbkt, &kp RBKT,     RM2 RB2)

SIMPLE_COMBO(dollar, &dlr_gbp,     RT3 RM3)
SIMPLE_COMBO(hash,   &kp GB_HASH,  RM3 RB3)

SIMPLE_COMBO(perc,  &kp PRCNT, RM4 RT4)
SIMPLE_COMBO(caret, &kp CARET, RM4 RB4)

/* left side combos */
SIMPLE_COMBO(grave, &kp GRAVE, LT0 LM0)
SIMPLE_COMBO(equal, &kp EQUAL, LB0 LM0)

SIMPLE_COMBO(excl, &kp EXCL, LT1 LM1)
SIMPLE_COMBO(lpar, &lpar_lt, LM1 LB1)

SIMPLE_COMBO(at,   &kp GB_AT, LT2 LM2)
SIMPLE_COMBO(lbkt, &kp LBKT,  LM2 LB2)

SIMPLE_COMBO(amps, &amps_eur, LT3 LM3)
SIMPLE_COMBO(star, &star_rup, LB3 LM3)

SIMPLE_COMBO(degree, &uc_deg, LT4 LM4)

/* horizontal combos */
SIMPLE_COMBO(ret, &kp RET, RB1 RB2)
SIMPLE_COMBO(tab, &kp TAB, LB1 LB2)
SIMPLE_COMBO(ret_mid, &kp RET, RB3 RB2)
SIMPLE_COMBO(tab_mid, &kp TAB, LB3 LB2)

/* Bootloader Combo for sending the "central" into bootloader mode */
SIMPLE_COMBO(bootloader, &bootloader, LT2 LT1 RT1 RT2)
SIMPLE_COMBO(reset, &sys_reset, LT1 RT1)

/* Mod Combos */
// This system utilizes the slow-release property to keep the layer enabled while one of the combo keys is active.
// This essentially allows the one-shot keys to be activated by either sequencing of the layer and mod key, instead of
// having to always press the layer key first.
#define MOD_LAYER_COMBO(MOD, LAYER, POSITIONS) \ 
        ZMK_BEHAVIOR(macro_##MOD##_##LAYER, macro, wait-ms = <0>; tap-ms = <0>; \
        bindings \
            = <&macro_press &mo LAYER> \
            , <&macro_press &sk MOD> \
            , <&macro_pause_for_release> \
            , <&macro_release &sk MOD> \
            , <&macro_release &mo LAYER> \
            ; \
    ) \
    ZMK_COMBO(combo_##MOD##_##LAYER, &macro_##MOD##_##LAYER, POSITIONS, COMBO_LAYERS, COMBO_TERM, COMBO_TERM, slow-release;)

#define MOD_LAYER_COMBO_2(MOD1, MOD2, LAYER, POSITIONS) \ 
        ZMK_BEHAVIOR(macro_##MOD1##_##MOD2##_##LAYER, macro, wait-ms = <0>; tap-ms = <0>; \
        bindings \
            = <&macro_press &mo LAYER> \
            , <&macro_press &sk MOD1> \
            , <&macro_press &sk MOD2> \
            , <&macro_pause_for_release> \
            , <&macro_release &sk MOD2> \
            , <&macro_release &sk MOD1> \
            , <&macro_release &mo LAYER> \
            ; \
    ) \
    ZMK_COMBO(combo_##MOD1##_##MOD2##_##LAYER, &macro_##MOD1##_##MOD2##_##LAYER, POSITIONS, COMBO_LAYERS, COMBO_TERM, COMBO_TERM, slow-release;)

MOD_LAYER_COMBO(LCTL, NAV, LH0 LM1)
MOD_LAYER_COMBO(LGUI, NAV, LH0 LM2)
MOD_LAYER_COMBO(LALT, NAV, LH0 LM3)
MOD_LAYER_COMBO(LSFT, NAV, LH0 LM4)
MOD_LAYER_COMBO_2(LGUI, LCTL, NAV, LH0 LM2 LM1)
MOD_LAYER_COMBO_2(LGUI, LALT, NAV, LH0 LM2 LM3)
MOD_LAYER_COMBO_2(LGUI, LSFT, NAV, LH0 LM2 LM4)
MOD_LAYER_COMBO_2(LCTL, LALT, NAV, LH0 LM1 LM3)
MOD_LAYER_COMBO_2(LCTL, LSFT, NAV, LH0 LM1 LM4)

// vi:ft=devicetree
